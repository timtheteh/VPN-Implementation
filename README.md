A brief description of how your VPN works:
- Assuming the secure connection is established, when the client/server sends a message, the `plain_text` passes through a function `EncryptAndProtectMessage()` with takes the `plain_text` and encrypts it using the `Fernet` primitive from the `cryptography` library. Similarly, when the client/server receives a message, the `cipher_text` passes through a function `DecryptAndVerifyMessage()` which takes the `cipher_text` and decrypts it using the `Fernet` primitive. The `Fernet` primitives protect the message using `AES` in `CBC` mode with a 128-bit key for encryption to ensure confidentiality and `HMAC` using `SHA256` for integrity. Therefore, even if the attacker is able to intercept the message, the attacker would not be able to understand the message and if the attacker attempts to modify the message, an exception would be raised, alerting the users.
<img width="462" alt="image" src="https://user-images.githubusercontent.com/76463517/199397108-628e9f57-6ab0-4eca-a97d-da9227a23010.png">

A discussion of the mutual authentication and key establishment protocols you chose to use, why you chose them, and the computation performed by each side at each step in the protocol(s).
- In the first step, the client initiates the protocol by sending the protocol header and a nonce. The nonce is generated using python’s `secrets` package and is required to prevent replay attacks. In the second step, the server replies by sending the header, an encrypted message which contains the identity (“SERVER”), client’s nonce and the session key, as well as the server’s nonce.  The server’s nonce serves the same purpose.  The session key is generated using the `Fernet` primitive. The encrypted message is encrypted using `AES` in `ECB` mode. We use `ECB` mode because the size of the encrypted message (<= 32 bytes) is smaller than the stretched shared key, resulting in the encryption being essentially a one-time pad and since we are using the shared key only for the protocol, the security will not be heavily compromised. In the third step, the client decrypts the encrypted message in the second step to authenticate the identity of the server by checking that the decrypted nonce is indeed the nonce that the client sent in the first step. Since the server is the only other party that has the shared key, the server is the only other party that can generate the encrypted message, thereby authenticating the server. The identity (“SERVER”) is required to prevent man-in-the-middle attack. The client also retrieves the session key generated by the server from the decrypted message. The client then essentially does the same by sending the server another encrypted message for the server to authenticate its identity.  At the end of the 3 steps, we would have mutual authentication and key establishment. The protocol when initiated by the server is the same but with the nonce and identity swapped. 

A discussion of how you derive encryption and integrity-protection keys from the shared secret value:
- The shared secret value is used for mutual authentication and encrypting the session key. It is not used to derive the encryption and integrity-protection keys.

A short answer to the following question: if you were implementing this VPN as a real-world product for sale, what algorithms, modulus sizes, encryption key size, and integrity key size would you use?
- We would use the current best practice of AES with 128/256 bit keys depending on the sensitivity of the data.
